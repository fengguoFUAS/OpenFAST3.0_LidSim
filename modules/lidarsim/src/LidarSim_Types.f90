!STARTOFREGISTRYGENERATEDFILE 'LidarSim_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! LidarSim_Types
!.................................................................................................................................
! This file is part of LidarSim.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in LidarSim. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE LidarSim_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  LidarSim_InitInputType  =======
  TYPE, PUBLIC :: LidarSim_InitInputType
    CHARACTER(1024)  :: RootName 
    CHARACTER(1024)  :: InputInitFile      !< Name of the Input file [-]
    REAL(ReKi)  :: DT      !< Step size [-]
  END TYPE LidarSim_InitInputType
! =======================
! =========  LidarSim_InitOutputType  =======
  TYPE, PUBLIC :: LidarSim_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !< Names of output-to-file channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !< Units of output-to-file channels [-]
  END TYPE LidarSim_InitOutputType
! =======================
! =========  LidarSim_OutputType  =======
  TYPE, PUBLIC :: LidarSim_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !< Array with values to output to file [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: SwapOutputs      !< Array with values to output to avrSwap array [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AllOutputs      !< Array containing all possible outputs [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: IMUOutputs      !< Array containing Position, Velocity, and Acceleration of the lidar system [-]
  END TYPE LidarSim_OutputType
! =======================
! =========  LidarSim_ParameterType  =======
  TYPE, PUBLIC :: LidarSim_ParameterType
    INTEGER(IntKi)  :: MeasurementMaxSteps      !< Time steps between lidar measurements [-]
    INTEGER(IntKi)  :: MeasurementCurrentStep      !< Current amount of time steps after last measurement [-]
    INTEGER(IntKi)  :: MeasurementTimeStep      !< Current time steps of lidar measurement [-]
    INTEGER(IntKi)  :: LastMeasuringPoint      !< Index of last measuring point [-]
    REAL(ReKi)  :: LidarPosition_N(3)      !< Lidar position in the nacelle coordinates [m]
    REAL(ReKi)  :: LidarOrientation_N(3,3)      !< orientation of the lidar system in the nacelle coordinate system [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MeasuringPoints_L      !< 2D Array of all measuringpoints, first dimension is always 3 [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MeasuringPoints_Spherical_L      !< 2D Array of all measuringpoints, first dimension is always 3 (spherical representation) [deg]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WeightingDistance      !< Distances to evalute for the weighting [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Weighting      !< weighting of different positions [-]
    REAL(ReKi)  :: URef      !< Mean u-component wind speed at the reference height [m/s]
    INTEGER(IntKi)  :: GatesPerBeam      !< Amount of gates per point [-]
    INTEGER(IntKi)  :: NextBeamID      !< BeamID for the next measurement [-]
    INTEGER(IntKi)  :: MAXDLLChainOutputs      !< Number of entries in the avrSWAP reserved for the DLL chain [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ValidOutputs      !< List of valid output channels [-]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), ALLOCATABLE  :: FFData      !< Array of Bladed style wind data,used to calculate lidar measurement [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: X_unfrozen      !< A array contains the unfrozen y-z planes [-]
    INTEGER(IntKi)  :: Nlongi      !< Bumber of unfrozen y-z planes [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AvaiData      !< Array of measurement availability data [-]
    REAL(ReKi)  :: AvaiTimeEnd = 0      !< The total time of the availability data [seconds]
    LOGICAL  :: Periodic = .FALSE.      !< Flag to indicate if the wind file is periodic [-]
    LOGICAL  :: TowerDataExist = .FALSE.      !< If true, we specified a tower file [-]
    REAL(DbKi)  :: DT      !< Time step for cont. state integration & disc. state update [seconds]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: FFTower      !< Array of data along tower, below FF array [-]
    REAL(ReKi)  :: FFDTime = 0      !< Delta time [seconds]
    REAL(ReKi)  :: FFRate = 0      !< Data rate (1/FFTime) [Hertz]
    REAL(ReKi)  :: FFYHWid = 0      !< Half the grid width [meters]
    REAL(ReKi)  :: FFZHWid = 0      !< Half the grid height [meters]
    REAL(ReKi)  :: RefHt = 0      !< Reference (hub) height of the grid [meters]
    REAL(ReKi)  :: GridBase = 0      !< the height of the bottom of the grid [meters]
    REAL(ReKi)  :: InitXPosition = 0      !< the initial x position of grid (distance in FF is offset) [meters]
    REAL(ReKi)  :: InvFFYD = 0      !< reciprocal of delta y [1/meters]
    REAL(ReKi)  :: InvFFZD = 0      !< reciprocal of delta z [1/meters]
    REAL(ReKi)  :: InvMFFWS = 0      !< reciprocal of mean wind speed (MeanFFWS) [seconds/meter]
    REAL(ReKi)  :: MeanFFWS = 0      !< Mean wind speed (as defined in FF file), not necessarily of the portion used [meters/second]
    REAL(ReKi)  :: TotalTime = 0      !< The total time of the simulation [seconds]
    INTEGER(IntKi)  :: NFFComp = 3      !< Number of wind components [-]
    INTEGER(IntKi)  :: NFFSteps = 0      !< Number of time steps in the FF array [-]
    INTEGER(IntKi)  :: NYGrids = 0      !< Number of points in the lateral (y) direction of the grids [-]
    INTEGER(IntKi)  :: NZGrids = 0      !< Number of points in the vertical (z) direction of the grids [-]
    INTEGER(IntKi)  :: NTGrids = 0      !< Number of points in the vertical (z) direction on the tower (below the grids) [-]
    INTEGER(IntKi)  :: WindFileFormat      !< Binary file format description number [-]
    LOGICAL  :: EvolutionFlag      !< Flag whether evolution considered [-]
    LOGICAL  :: AvailabilityFlag      !< Flag whether measurement availability due to CNR considered [-]
    LOGICAL  :: BladeBlockageFlag      !< Flag whether blade blockage considered [-]
    LOGICAL  :: SpinnerMountedFlag      !< Flag whether the lidar is Mounted on spinner [-]
    LOGICAL  :: NearestInterpFlag      !< Flag to use nearest interpolation [-]
    INTEGER(IntKi)  :: NBlade      !< Number of blades, needed for lidar beam blockage detection [-]
    INTEGER(IntKi)  :: NELM      !< Number of blade element, needed for lidar beam blockage detection [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BladeELMCL      !< Chord length of blade element [-]
    INTEGER(IntKi)  :: AeroynMode      !< Aerodyn mode, required to determine blade geometry for blockage detection, 14 or 15 [-]
  END TYPE LidarSim_ParameterType
! =======================
! =========  LidarSim_InputType  =======
  TYPE, PUBLIC :: LidarSim_InputType
    TYPE(MeshType)  :: NacelleMotion      !< . [-]
    TYPE(MeshType)  :: HubMotion      !< motion on the hub [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeMotion      !< motion on each blade [-]
  END TYPE LidarSim_InputType
! =======================
! =========  LidarSim_InputFile  =======
  TYPE, PUBLIC :: LidarSim_InputFile
    LOGICAL  :: Echo      !< Echo input data to <RootName>.ech [-]
    INTEGER(IntKi)  :: MAXDLLChainOutputs      !< Number of entries in the avrSWAP reserved for the DLL chain [-]
    INTEGER(IntKi)  :: TrajectoryType      !< Switch : {0 = cartesian coordinates; 1 = spherical coordinates} [-]
    INTEGER(IntKi)  :: WeightingType      !< Switch : {0 = single point; 1 = gaussian distribution} [-]
    REAL(ReKi)  :: LidarPositionX_N      !< Units of output-to-file channels [-]
    REAL(ReKi)  :: LidarPositionY_N      !< Names of output-to-file channels [-]
    REAL(ReKi)  :: LidarPositionZ_N      !< Units of output-to-file channels [-]
    REAL(ReKi)  :: RollAngle_N      !< Roll angle between the Nacelle and the lidar coordinate system [-]
    REAL(ReKi)  :: PitchAngle_N      !< Pitch angle between the Nacelle and the lidar coordinate system [-]
    REAL(ReKi)  :: YawAngle_N      !< Yaw angle between the Nacelle and the lidar coordinate system [-]
    REAL(ReKi)  :: URef      !< Mean u-component wind speed at the reference height [m/s]
    REAL(ReKi)  :: t_measurement_interval      !< Time between each measurement [s]
    INTEGER(IntKi)  :: NumberOfPoints_Cartesian      !< Amount of Points [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: X_Cartesian_L      !< X Coordinate (Lidar coordinate system) [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Y_Cartesian_L      !< X Coordinate (Lidar coordinate system) [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Z_Cartesian_L      !< X Coordinate (Lidar coordinate system) [m]
    INTEGER(IntKi)  :: NumberOfPoints_Spherical      !< Amount of Points [-]
    INTEGER(IntKi)  :: GatesPerBeam      !< Amount of gates per point [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Azimuth      !< Azimuth Angles  [deg]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Elevation      !< Elevation Angles  [deg]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Range      !< Range gates  [m]
    REAL(ReKi)  :: FWHM      !< Width of half maximum [m]
    INTEGER(IntKi)  :: PointsToEvaluate      !< points evaluated to "integrate" (odd number so there is a point in the peak) [-]
    INTEGER(IntKi)  :: ManualWeightingPoints      !< Amount of weighting points [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ManualWeightingDistance      !< Manual weighting distances [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ManualWeighting      !< Manual weighting [-]
    LOGICAL  :: EvolutionFlag      !< Flag whether evolution considered [-]
    CHARACTER(1024)  :: EvolutionFilenameRoot      !< Rootname of the up-stream full-field wind file to use (.wnd, .sum) [-]
    LOGICAL  :: AvailabilityFlag      !< Flag whether measurement availability due to CNR considered [-]
    CHARACTER(1024)  :: AvailabilityFilenameRoot      !< Rootname of the lidar data availability flag, generated by lidar CNR simulator (.dat) [-]
    LOGICAL  :: BladeBlockageFlag      !< Flag whether blade blockage is considered [-]
    LOGICAL  :: SpinnerMountedFlag      !< Flag whether rotational sampling is considered [-]
    LOGICAL  :: NearestInterpFlag      !< Flag to use nearest interpolation [-]
    CHARACTER(15) , DIMENSION(:), ALLOCATABLE  :: OutList      !< User requested Outlist [-]
    INTEGER(IntKi)  :: NumOuts      !< Number of output parameters [-]
  END TYPE LidarSim_InputFile
! =======================
CONTAINS
 SUBROUTINE LidarSim_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(LidarSim_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(LidarSim_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%RootName = SrcInitInputData%RootName
    DstInitInputData%InputInitFile = SrcInitInputData%InputInitFile
    DstInitInputData%DT = SrcInitInputData%DT
 END SUBROUTINE LidarSim_CopyInitInput

 SUBROUTINE LidarSim_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(LidarSim_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'LidarSim_DestroyInitInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE LidarSim_DestroyInitInput

 SUBROUTINE LidarSim_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(LidarSim_InitInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_PackInitInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%RootName)  ! RootName
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%InputInitFile)  ! InputInitFile
      Re_BufSz   = Re_BufSz   + 1  ! DT
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    DO I = 1, LEN(InData%RootName)
      IntKiBuf(Int_Xferred) = ICHAR(InData%RootName(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(InData%InputInitFile)
      IntKiBuf(Int_Xferred) = ICHAR(InData%InputInitFile(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    ReKiBuf(Re_Xferred) = InData%DT
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE LidarSim_PackInitInput

 SUBROUTINE LidarSim_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(LidarSim_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_UnPackInitInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    DO I = 1, LEN(OutData%RootName)
      OutData%RootName(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(OutData%InputInitFile)
      OutData%InputInitFile(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%DT = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE LidarSim_UnPackInitInput

 SUBROUTINE LidarSim_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(LidarSim_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(LidarSim_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
 END SUBROUTINE LidarSim_CopyInitOutput

 SUBROUTINE LidarSim_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(LidarSim_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'LidarSim_DestroyInitOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
  DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
  DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
 END SUBROUTINE LidarSim_DestroyInitOutput

 SUBROUTINE LidarSim_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(LidarSim_InitOutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_PackInitOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! WriteOutputHdr allocated yes/no
  IF ( ALLOCATED(InData%WriteOutputHdr) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WriteOutputHdr upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%WriteOutputHdr)*LEN(InData%WriteOutputHdr)  ! WriteOutputHdr
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WriteOutputUnt allocated yes/no
  IF ( ALLOCATED(InData%WriteOutputUnt) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WriteOutputUnt upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%WriteOutputUnt)*LEN(InData%WriteOutputUnt)  ! WriteOutputUnt
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%WriteOutputHdr) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WriteOutputHdr,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WriteOutputHdr,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WriteOutputHdr,1), UBOUND(InData%WriteOutputHdr,1)
        DO I = 1, LEN(InData%WriteOutputHdr)
          IntKiBuf(Int_Xferred) = ICHAR(InData%WriteOutputHdr(i1)(I:I), IntKi)
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WriteOutputUnt) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WriteOutputUnt,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WriteOutputUnt,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WriteOutputUnt,1), UBOUND(InData%WriteOutputUnt,1)
        DO I = 1, LEN(InData%WriteOutputUnt)
          IntKiBuf(Int_Xferred) = ICHAR(InData%WriteOutputUnt(i1)(I:I), IntKi)
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
 END SUBROUTINE LidarSim_PackInitOutput

 SUBROUTINE LidarSim_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(LidarSim_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_UnPackInitOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WriteOutputHdr not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WriteOutputHdr)) DEALLOCATE(OutData%WriteOutputHdr)
    ALLOCATE(OutData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WriteOutputHdr,1), UBOUND(OutData%WriteOutputHdr,1)
        DO I = 1, LEN(OutData%WriteOutputHdr)
          OutData%WriteOutputHdr(i1)(I:I) = CHAR(IntKiBuf(Int_Xferred))
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WriteOutputUnt not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WriteOutputUnt)) DEALLOCATE(OutData%WriteOutputUnt)
    ALLOCATE(OutData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WriteOutputUnt,1), UBOUND(OutData%WriteOutputUnt,1)
        DO I = 1, LEN(OutData%WriteOutputUnt)
          OutData%WriteOutputUnt(i1)(I:I) = CHAR(IntKiBuf(Int_Xferred))
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
 END SUBROUTINE LidarSim_UnPackInitOutput

 SUBROUTINE LidarSim_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(LidarSim_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(LidarSim_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
  i1_l = LBOUND(SrcOutputData%WriteOutput,1)
  i1_u = UBOUND(SrcOutputData%WriteOutput,1)
  IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
    ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
IF (ALLOCATED(SrcOutputData%SwapOutputs)) THEN
  i1_l = LBOUND(SrcOutputData%SwapOutputs,1)
  i1_u = UBOUND(SrcOutputData%SwapOutputs,1)
  IF (.NOT. ALLOCATED(DstOutputData%SwapOutputs)) THEN 
    ALLOCATE(DstOutputData%SwapOutputs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%SwapOutputs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%SwapOutputs = SrcOutputData%SwapOutputs
ENDIF
IF (ALLOCATED(SrcOutputData%AllOutputs)) THEN
  i1_l = LBOUND(SrcOutputData%AllOutputs,1)
  i1_u = UBOUND(SrcOutputData%AllOutputs,1)
  IF (.NOT. ALLOCATED(DstOutputData%AllOutputs)) THEN 
    ALLOCATE(DstOutputData%AllOutputs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%AllOutputs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%AllOutputs = SrcOutputData%AllOutputs
ENDIF
IF (ALLOCATED(SrcOutputData%IMUOutputs)) THEN
  i1_l = LBOUND(SrcOutputData%IMUOutputs,1)
  i1_u = UBOUND(SrcOutputData%IMUOutputs,1)
  IF (.NOT. ALLOCATED(DstOutputData%IMUOutputs)) THEN 
    ALLOCATE(DstOutputData%IMUOutputs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%IMUOutputs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%IMUOutputs = SrcOutputData%IMUOutputs
ENDIF
 END SUBROUTINE LidarSim_CopyOutput

 SUBROUTINE LidarSim_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(LidarSim_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'LidarSim_DestroyOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%WriteOutput)) THEN
  DEALLOCATE(OutputData%WriteOutput)
ENDIF
IF (ALLOCATED(OutputData%SwapOutputs)) THEN
  DEALLOCATE(OutputData%SwapOutputs)
ENDIF
IF (ALLOCATED(OutputData%AllOutputs)) THEN
  DEALLOCATE(OutputData%AllOutputs)
ENDIF
IF (ALLOCATED(OutputData%IMUOutputs)) THEN
  DEALLOCATE(OutputData%IMUOutputs)
ENDIF
 END SUBROUTINE LidarSim_DestroyOutput

 SUBROUTINE LidarSim_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(LidarSim_OutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_PackOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! WriteOutput allocated yes/no
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WriteOutput upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WriteOutput)  ! WriteOutput
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! SwapOutputs allocated yes/no
  IF ( ALLOCATED(InData%SwapOutputs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! SwapOutputs upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%SwapOutputs)  ! SwapOutputs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AllOutputs allocated yes/no
  IF ( ALLOCATED(InData%AllOutputs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! AllOutputs upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AllOutputs)  ! AllOutputs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! IMUOutputs allocated yes/no
  IF ( ALLOCATED(InData%IMUOutputs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! IMUOutputs upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%IMUOutputs)  ! IMUOutputs
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%WriteOutput) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WriteOutput,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WriteOutput,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WriteOutput,1), UBOUND(InData%WriteOutput,1)
        ReKiBuf(Re_Xferred) = InData%WriteOutput(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%SwapOutputs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%SwapOutputs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%SwapOutputs,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%SwapOutputs,1), UBOUND(InData%SwapOutputs,1)
        ReKiBuf(Re_Xferred) = InData%SwapOutputs(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%AllOutputs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AllOutputs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AllOutputs,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%AllOutputs,1), UBOUND(InData%AllOutputs,1)
        ReKiBuf(Re_Xferred) = InData%AllOutputs(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%IMUOutputs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%IMUOutputs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%IMUOutputs,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%IMUOutputs,1), UBOUND(InData%IMUOutputs,1)
        ReKiBuf(Re_Xferred) = InData%IMUOutputs(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
 END SUBROUTINE LidarSim_PackOutput

 SUBROUTINE LidarSim_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(LidarSim_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_UnPackOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WriteOutput not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WriteOutput)) DEALLOCATE(OutData%WriteOutput)
    ALLOCATE(OutData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WriteOutput,1), UBOUND(OutData%WriteOutput,1)
        OutData%WriteOutput(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! SwapOutputs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%SwapOutputs)) DEALLOCATE(OutData%SwapOutputs)
    ALLOCATE(OutData%SwapOutputs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%SwapOutputs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%SwapOutputs,1), UBOUND(OutData%SwapOutputs,1)
        OutData%SwapOutputs(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AllOutputs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AllOutputs)) DEALLOCATE(OutData%AllOutputs)
    ALLOCATE(OutData%AllOutputs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AllOutputs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%AllOutputs,1), UBOUND(OutData%AllOutputs,1)
        OutData%AllOutputs(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! IMUOutputs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%IMUOutputs)) DEALLOCATE(OutData%IMUOutputs)
    ALLOCATE(OutData%IMUOutputs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%IMUOutputs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%IMUOutputs,1), UBOUND(OutData%IMUOutputs,1)
        OutData%IMUOutputs(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
 END SUBROUTINE LidarSim_UnPackOutput

 SUBROUTINE LidarSim_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(LidarSim_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(LidarSim_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%MeasurementMaxSteps = SrcParamData%MeasurementMaxSteps
    DstParamData%MeasurementCurrentStep = SrcParamData%MeasurementCurrentStep
    DstParamData%MeasurementTimeStep = SrcParamData%MeasurementTimeStep
    DstParamData%LastMeasuringPoint = SrcParamData%LastMeasuringPoint
    DstParamData%LidarPosition_N(3) = SrcParamData%LidarPosition_N(3)
    DstParamData%LidarOrientation_N(3,3) = SrcParamData%LidarOrientation_N(3,3)
IF (ALLOCATED(SrcParamData%MeasuringPoints_L)) THEN
  i1_l = LBOUND(SrcParamData%MeasuringPoints_L,1)
  i1_u = UBOUND(SrcParamData%MeasuringPoints_L,1)
  i2_l = LBOUND(SrcParamData%MeasuringPoints_L,2)
  i2_u = UBOUND(SrcParamData%MeasuringPoints_L,2)
  IF (.NOT. ALLOCATED(DstParamData%MeasuringPoints_L)) THEN 
    ALLOCATE(DstParamData%MeasuringPoints_L(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MeasuringPoints_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%MeasuringPoints_L = SrcParamData%MeasuringPoints_L
ENDIF
IF (ALLOCATED(SrcParamData%MeasuringPoints_Spherical_L)) THEN
  i1_l = LBOUND(SrcParamData%MeasuringPoints_Spherical_L,1)
  i1_u = UBOUND(SrcParamData%MeasuringPoints_Spherical_L,1)
  i2_l = LBOUND(SrcParamData%MeasuringPoints_Spherical_L,2)
  i2_u = UBOUND(SrcParamData%MeasuringPoints_Spherical_L,2)
  IF (.NOT. ALLOCATED(DstParamData%MeasuringPoints_Spherical_L)) THEN 
    ALLOCATE(DstParamData%MeasuringPoints_Spherical_L(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MeasuringPoints_Spherical_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%MeasuringPoints_Spherical_L = SrcParamData%MeasuringPoints_Spherical_L
ENDIF
IF (ALLOCATED(SrcParamData%WeightingDistance)) THEN
  i1_l = LBOUND(SrcParamData%WeightingDistance,1)
  i1_u = UBOUND(SrcParamData%WeightingDistance,1)
  IF (.NOT. ALLOCATED(DstParamData%WeightingDistance)) THEN 
    ALLOCATE(DstParamData%WeightingDistance(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WeightingDistance.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WeightingDistance = SrcParamData%WeightingDistance
ENDIF
IF (ALLOCATED(SrcParamData%Weighting)) THEN
  i1_l = LBOUND(SrcParamData%Weighting,1)
  i1_u = UBOUND(SrcParamData%Weighting,1)
  IF (.NOT. ALLOCATED(DstParamData%Weighting)) THEN 
    ALLOCATE(DstParamData%Weighting(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Weighting.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Weighting = SrcParamData%Weighting
ENDIF
    DstParamData%URef = SrcParamData%URef
    DstParamData%GatesPerBeam = SrcParamData%GatesPerBeam
    DstParamData%NextBeamID = SrcParamData%NextBeamID
    DstParamData%MAXDLLChainOutputs = SrcParamData%MAXDLLChainOutputs
IF (ALLOCATED(SrcParamData%ValidOutputs)) THEN
  i1_l = LBOUND(SrcParamData%ValidOutputs,1)
  i1_u = UBOUND(SrcParamData%ValidOutputs,1)
  IF (.NOT. ALLOCATED(DstParamData%ValidOutputs)) THEN 
    ALLOCATE(DstParamData%ValidOutputs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ValidOutputs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%ValidOutputs = SrcParamData%ValidOutputs
ENDIF
IF (ALLOCATED(SrcParamData%FFData)) THEN
  i1_l = LBOUND(SrcParamData%FFData,1)
  i1_u = UBOUND(SrcParamData%FFData,1)
  i2_l = LBOUND(SrcParamData%FFData,2)
  i2_u = UBOUND(SrcParamData%FFData,2)
  i3_l = LBOUND(SrcParamData%FFData,3)
  i3_u = UBOUND(SrcParamData%FFData,3)
  i4_l = LBOUND(SrcParamData%FFData,4)
  i4_u = UBOUND(SrcParamData%FFData,4)
  i5_l = LBOUND(SrcParamData%FFData,5)
  i5_u = UBOUND(SrcParamData%FFData,5)
  IF (.NOT. ALLOCATED(DstParamData%FFData)) THEN 
    ALLOCATE(DstParamData%FFData(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u,i5_l:i5_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FFData.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%FFData = SrcParamData%FFData
ENDIF
IF (ALLOCATED(SrcParamData%X_unfrozen)) THEN
  i1_l = LBOUND(SrcParamData%X_unfrozen,1)
  i1_u = UBOUND(SrcParamData%X_unfrozen,1)
  IF (.NOT. ALLOCATED(DstParamData%X_unfrozen)) THEN 
    ALLOCATE(DstParamData%X_unfrozen(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%X_unfrozen.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%X_unfrozen = SrcParamData%X_unfrozen
ENDIF
    DstParamData%Nlongi = SrcParamData%Nlongi
IF (ALLOCATED(SrcParamData%AvaiData)) THEN
  i1_l = LBOUND(SrcParamData%AvaiData,1)
  i1_u = UBOUND(SrcParamData%AvaiData,1)
  i2_l = LBOUND(SrcParamData%AvaiData,2)
  i2_u = UBOUND(SrcParamData%AvaiData,2)
  IF (.NOT. ALLOCATED(DstParamData%AvaiData)) THEN 
    ALLOCATE(DstParamData%AvaiData(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AvaiData.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%AvaiData = SrcParamData%AvaiData
ENDIF
    DstParamData%AvaiTimeEnd = SrcParamData%AvaiTimeEnd
    DstParamData%Periodic = SrcParamData%Periodic
    DstParamData%TowerDataExist = SrcParamData%TowerDataExist
    DstParamData%DT = SrcParamData%DT
IF (ALLOCATED(SrcParamData%FFTower)) THEN
  i1_l = LBOUND(SrcParamData%FFTower,1)
  i1_u = UBOUND(SrcParamData%FFTower,1)
  i2_l = LBOUND(SrcParamData%FFTower,2)
  i2_u = UBOUND(SrcParamData%FFTower,2)
  i3_l = LBOUND(SrcParamData%FFTower,3)
  i3_u = UBOUND(SrcParamData%FFTower,3)
  IF (.NOT. ALLOCATED(DstParamData%FFTower)) THEN 
    ALLOCATE(DstParamData%FFTower(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FFTower.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%FFTower = SrcParamData%FFTower
ENDIF
    DstParamData%FFDTime = SrcParamData%FFDTime
    DstParamData%FFRate = SrcParamData%FFRate
    DstParamData%FFYHWid = SrcParamData%FFYHWid
    DstParamData%FFZHWid = SrcParamData%FFZHWid
    DstParamData%RefHt = SrcParamData%RefHt
    DstParamData%GridBase = SrcParamData%GridBase
    DstParamData%InitXPosition = SrcParamData%InitXPosition
    DstParamData%InvFFYD = SrcParamData%InvFFYD
    DstParamData%InvFFZD = SrcParamData%InvFFZD
    DstParamData%InvMFFWS = SrcParamData%InvMFFWS
    DstParamData%MeanFFWS = SrcParamData%MeanFFWS
    DstParamData%TotalTime = SrcParamData%TotalTime
    DstParamData%NFFComp = SrcParamData%NFFComp
    DstParamData%NFFSteps = SrcParamData%NFFSteps
    DstParamData%NYGrids = SrcParamData%NYGrids
    DstParamData%NZGrids = SrcParamData%NZGrids
    DstParamData%NTGrids = SrcParamData%NTGrids
    DstParamData%WindFileFormat = SrcParamData%WindFileFormat
    DstParamData%EvolutionFlag = SrcParamData%EvolutionFlag
    DstParamData%AvailabilityFlag = SrcParamData%AvailabilityFlag
    DstParamData%BladeBlockageFlag = SrcParamData%BladeBlockageFlag
    DstParamData%SpinnerMountedFlag = SrcParamData%SpinnerMountedFlag
    DstParamData%NearestInterpFlag = SrcParamData%NearestInterpFlag
    DstParamData%NBlade = SrcParamData%NBlade
    DstParamData%NELM = SrcParamData%NELM
IF (ALLOCATED(SrcParamData%BladeELMCL)) THEN
  i1_l = LBOUND(SrcParamData%BladeELMCL,1)
  i1_u = UBOUND(SrcParamData%BladeELMCL,1)
  IF (.NOT. ALLOCATED(DstParamData%BladeELMCL)) THEN 
    ALLOCATE(DstParamData%BladeELMCL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%BladeELMCL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%BladeELMCL = SrcParamData%BladeELMCL
ENDIF
    DstParamData%AeroynMode = SrcParamData%AeroynMode
 END SUBROUTINE LidarSim_CopyParam

 SUBROUTINE LidarSim_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(LidarSim_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'LidarSim_DestroyParam'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%MeasuringPoints_L)) THEN
  DEALLOCATE(ParamData%MeasuringPoints_L)
ENDIF
IF (ALLOCATED(ParamData%MeasuringPoints_Spherical_L)) THEN
  DEALLOCATE(ParamData%MeasuringPoints_Spherical_L)
ENDIF
IF (ALLOCATED(ParamData%WeightingDistance)) THEN
  DEALLOCATE(ParamData%WeightingDistance)
ENDIF
IF (ALLOCATED(ParamData%Weighting)) THEN
  DEALLOCATE(ParamData%Weighting)
ENDIF
IF (ALLOCATED(ParamData%ValidOutputs)) THEN
  DEALLOCATE(ParamData%ValidOutputs)
ENDIF
IF (ALLOCATED(ParamData%FFData)) THEN
  DEALLOCATE(ParamData%FFData)
ENDIF
IF (ALLOCATED(ParamData%X_unfrozen)) THEN
  DEALLOCATE(ParamData%X_unfrozen)
ENDIF
IF (ALLOCATED(ParamData%AvaiData)) THEN
  DEALLOCATE(ParamData%AvaiData)
ENDIF
IF (ALLOCATED(ParamData%FFTower)) THEN
  DEALLOCATE(ParamData%FFTower)
ENDIF
IF (ALLOCATED(ParamData%BladeELMCL)) THEN
  DEALLOCATE(ParamData%BladeELMCL)
ENDIF
 END SUBROUTINE LidarSim_DestroyParam

 SUBROUTINE LidarSim_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(LidarSim_ParameterType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_PackParam'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! MeasurementMaxSteps
      Int_BufSz  = Int_BufSz  + 1  ! MeasurementCurrentStep
      Int_BufSz  = Int_BufSz  + 1  ! MeasurementTimeStep
      Int_BufSz  = Int_BufSz  + 1  ! LastMeasuringPoint
      Re_BufSz   = Re_BufSz   + 1  ! LidarPosition_N(3)
      Re_BufSz   = Re_BufSz   + 1  ! LidarOrientation_N(3,3)
  Int_BufSz   = Int_BufSz   + 1     ! MeasuringPoints_L allocated yes/no
  IF ( ALLOCATED(InData%MeasuringPoints_L) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! MeasuringPoints_L upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%MeasuringPoints_L)  ! MeasuringPoints_L
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! MeasuringPoints_Spherical_L allocated yes/no
  IF ( ALLOCATED(InData%MeasuringPoints_Spherical_L) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! MeasuringPoints_Spherical_L upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%MeasuringPoints_Spherical_L)  ! MeasuringPoints_Spherical_L
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WeightingDistance allocated yes/no
  IF ( ALLOCATED(InData%WeightingDistance) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WeightingDistance upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WeightingDistance)  ! WeightingDistance
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Weighting allocated yes/no
  IF ( ALLOCATED(InData%Weighting) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Weighting upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Weighting)  ! Weighting
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! URef
      Int_BufSz  = Int_BufSz  + 1  ! GatesPerBeam
      Int_BufSz  = Int_BufSz  + 1  ! NextBeamID
      Int_BufSz  = Int_BufSz  + 1  ! MAXDLLChainOutputs
  Int_BufSz   = Int_BufSz   + 1     ! ValidOutputs allocated yes/no
  IF ( ALLOCATED(InData%ValidOutputs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ValidOutputs upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%ValidOutputs)  ! ValidOutputs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! FFData allocated yes/no
  IF ( ALLOCATED(InData%FFData) ) THEN
    Int_BufSz   = Int_BufSz   + 2*5  ! FFData upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%FFData)  ! FFData
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! X_unfrozen allocated yes/no
  IF ( ALLOCATED(InData%X_unfrozen) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! X_unfrozen upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%X_unfrozen)  ! X_unfrozen
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! Nlongi
  Int_BufSz   = Int_BufSz   + 1     ! AvaiData allocated yes/no
  IF ( ALLOCATED(InData%AvaiData) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! AvaiData upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AvaiData)  ! AvaiData
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! AvaiTimeEnd
      Int_BufSz  = Int_BufSz  + 1  ! Periodic
      Int_BufSz  = Int_BufSz  + 1  ! TowerDataExist
      Db_BufSz   = Db_BufSz   + 1  ! DT
  Int_BufSz   = Int_BufSz   + 1     ! FFTower allocated yes/no
  IF ( ALLOCATED(InData%FFTower) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! FFTower upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%FFTower)  ! FFTower
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! FFDTime
      Re_BufSz   = Re_BufSz   + 1  ! FFRate
      Re_BufSz   = Re_BufSz   + 1  ! FFYHWid
      Re_BufSz   = Re_BufSz   + 1  ! FFZHWid
      Re_BufSz   = Re_BufSz   + 1  ! RefHt
      Re_BufSz   = Re_BufSz   + 1  ! GridBase
      Re_BufSz   = Re_BufSz   + 1  ! InitXPosition
      Re_BufSz   = Re_BufSz   + 1  ! InvFFYD
      Re_BufSz   = Re_BufSz   + 1  ! InvFFZD
      Re_BufSz   = Re_BufSz   + 1  ! InvMFFWS
      Re_BufSz   = Re_BufSz   + 1  ! MeanFFWS
      Re_BufSz   = Re_BufSz   + 1  ! TotalTime
      Int_BufSz  = Int_BufSz  + 1  ! NFFComp
      Int_BufSz  = Int_BufSz  + 1  ! NFFSteps
      Int_BufSz  = Int_BufSz  + 1  ! NYGrids
      Int_BufSz  = Int_BufSz  + 1  ! NZGrids
      Int_BufSz  = Int_BufSz  + 1  ! NTGrids
      Int_BufSz  = Int_BufSz  + 1  ! WindFileFormat
      Int_BufSz  = Int_BufSz  + 1  ! EvolutionFlag
      Int_BufSz  = Int_BufSz  + 1  ! AvailabilityFlag
      Int_BufSz  = Int_BufSz  + 1  ! BladeBlockageFlag
      Int_BufSz  = Int_BufSz  + 1  ! SpinnerMountedFlag
      Int_BufSz  = Int_BufSz  + 1  ! NearestInterpFlag
      Int_BufSz  = Int_BufSz  + 1  ! NBlade
      Int_BufSz  = Int_BufSz  + 1  ! NELM
  Int_BufSz   = Int_BufSz   + 1     ! BladeELMCL allocated yes/no
  IF ( ALLOCATED(InData%BladeELMCL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BladeELMCL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BladeELMCL)  ! BladeELMCL
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! AeroynMode
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%MeasurementMaxSteps
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MeasurementCurrentStep
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MeasurementTimeStep
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%LastMeasuringPoint
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%LidarPosition_N(3)
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%LidarOrientation_N(3,3)
    Re_Xferred = Re_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%MeasuringPoints_L) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MeasuringPoints_L,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MeasuringPoints_L,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MeasuringPoints_L,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MeasuringPoints_L,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%MeasuringPoints_L,2), UBOUND(InData%MeasuringPoints_L,2)
        DO i1 = LBOUND(InData%MeasuringPoints_L,1), UBOUND(InData%MeasuringPoints_L,1)
          ReKiBuf(Re_Xferred) = InData%MeasuringPoints_L(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%MeasuringPoints_Spherical_L) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MeasuringPoints_Spherical_L,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MeasuringPoints_Spherical_L,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MeasuringPoints_Spherical_L,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MeasuringPoints_Spherical_L,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%MeasuringPoints_Spherical_L,2), UBOUND(InData%MeasuringPoints_Spherical_L,2)
        DO i1 = LBOUND(InData%MeasuringPoints_Spherical_L,1), UBOUND(InData%MeasuringPoints_Spherical_L,1)
          ReKiBuf(Re_Xferred) = InData%MeasuringPoints_Spherical_L(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WeightingDistance) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WeightingDistance,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WeightingDistance,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WeightingDistance,1), UBOUND(InData%WeightingDistance,1)
        ReKiBuf(Re_Xferred) = InData%WeightingDistance(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Weighting) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Weighting,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Weighting,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Weighting,1), UBOUND(InData%Weighting,1)
        ReKiBuf(Re_Xferred) = InData%Weighting(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%URef
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%GatesPerBeam
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NextBeamID
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MAXDLLChainOutputs
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%ValidOutputs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ValidOutputs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ValidOutputs,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%ValidOutputs,1), UBOUND(InData%ValidOutputs,1)
        IntKiBuf(Int_Xferred) = InData%ValidOutputs(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%FFData) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FFData,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FFData,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FFData,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FFData,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FFData,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FFData,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FFData,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FFData,4)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FFData,5)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FFData,5)
    Int_Xferred = Int_Xferred + 2

      DO i5 = LBOUND(InData%FFData,5), UBOUND(InData%FFData,5)
        DO i4 = LBOUND(InData%FFData,4), UBOUND(InData%FFData,4)
          DO i3 = LBOUND(InData%FFData,3), UBOUND(InData%FFData,3)
            DO i2 = LBOUND(InData%FFData,2), UBOUND(InData%FFData,2)
              DO i1 = LBOUND(InData%FFData,1), UBOUND(InData%FFData,1)
                ReKiBuf(Re_Xferred) = InData%FFData(i1,i2,i3,i4,i5)
                Re_Xferred = Re_Xferred + 1
              END DO
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%X_unfrozen) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%X_unfrozen,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%X_unfrozen,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%X_unfrozen,1), UBOUND(InData%X_unfrozen,1)
        ReKiBuf(Re_Xferred) = InData%X_unfrozen(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%Nlongi
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%AvaiData) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AvaiData,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AvaiData,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AvaiData,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AvaiData,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%AvaiData,2), UBOUND(InData%AvaiData,2)
        DO i1 = LBOUND(InData%AvaiData,1), UBOUND(InData%AvaiData,1)
          ReKiBuf(Re_Xferred) = InData%AvaiData(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%AvaiTimeEnd
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%Periodic, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%TowerDataExist, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%DT
    Db_Xferred = Db_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%FFTower) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FFTower,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FFTower,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FFTower,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FFTower,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FFTower,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FFTower,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%FFTower,3), UBOUND(InData%FFTower,3)
        DO i2 = LBOUND(InData%FFTower,2), UBOUND(InData%FFTower,2)
          DO i1 = LBOUND(InData%FFTower,1), UBOUND(InData%FFTower,1)
            ReKiBuf(Re_Xferred) = InData%FFTower(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%FFDTime
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%FFRate
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%FFYHWid
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%FFZHWid
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%RefHt
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%GridBase
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InitXPosition
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InvFFYD
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InvFFZD
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InvMFFWS
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MeanFFWS
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%TotalTime
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NFFComp
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NFFSteps
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NYGrids
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NZGrids
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NTGrids
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WindFileFormat
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%EvolutionFlag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%AvailabilityFlag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%BladeBlockageFlag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%SpinnerMountedFlag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%NearestInterpFlag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NBlade
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NELM
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%BladeELMCL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BladeELMCL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BladeELMCL,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BladeELMCL,1), UBOUND(InData%BladeELMCL,1)
        ReKiBuf(Re_Xferred) = InData%BladeELMCL(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%AeroynMode
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE LidarSim_PackParam

 SUBROUTINE LidarSim_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(LidarSim_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_UnPackParam'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%MeasurementMaxSteps = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MeasurementCurrentStep = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MeasurementTimeStep = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%LastMeasuringPoint = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%LidarPosition_N(3) = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%LidarOrientation_N(3,3) = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! MeasuringPoints_L not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%MeasuringPoints_L)) DEALLOCATE(OutData%MeasuringPoints_L)
    ALLOCATE(OutData%MeasuringPoints_L(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%MeasuringPoints_L.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%MeasuringPoints_L,2), UBOUND(OutData%MeasuringPoints_L,2)
        DO i1 = LBOUND(OutData%MeasuringPoints_L,1), UBOUND(OutData%MeasuringPoints_L,1)
          OutData%MeasuringPoints_L(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! MeasuringPoints_Spherical_L not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%MeasuringPoints_Spherical_L)) DEALLOCATE(OutData%MeasuringPoints_Spherical_L)
    ALLOCATE(OutData%MeasuringPoints_Spherical_L(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%MeasuringPoints_Spherical_L.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%MeasuringPoints_Spherical_L,2), UBOUND(OutData%MeasuringPoints_Spherical_L,2)
        DO i1 = LBOUND(OutData%MeasuringPoints_Spherical_L,1), UBOUND(OutData%MeasuringPoints_Spherical_L,1)
          OutData%MeasuringPoints_Spherical_L(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WeightingDistance not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WeightingDistance)) DEALLOCATE(OutData%WeightingDistance)
    ALLOCATE(OutData%WeightingDistance(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WeightingDistance.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WeightingDistance,1), UBOUND(OutData%WeightingDistance,1)
        OutData%WeightingDistance(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Weighting not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Weighting)) DEALLOCATE(OutData%Weighting)
    ALLOCATE(OutData%Weighting(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Weighting.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Weighting,1), UBOUND(OutData%Weighting,1)
        OutData%Weighting(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%URef = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%GatesPerBeam = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NextBeamID = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%MAXDLLChainOutputs = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ValidOutputs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ValidOutputs)) DEALLOCATE(OutData%ValidOutputs)
    ALLOCATE(OutData%ValidOutputs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ValidOutputs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%ValidOutputs,1), UBOUND(OutData%ValidOutputs,1)
        OutData%ValidOutputs(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FFData not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i5_l = IntKiBuf( Int_Xferred    )
    i5_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FFData)) DEALLOCATE(OutData%FFData)
    ALLOCATE(OutData%FFData(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u,i5_l:i5_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FFData.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i5 = LBOUND(OutData%FFData,5), UBOUND(OutData%FFData,5)
        DO i4 = LBOUND(OutData%FFData,4), UBOUND(OutData%FFData,4)
          DO i3 = LBOUND(OutData%FFData,3), UBOUND(OutData%FFData,3)
            DO i2 = LBOUND(OutData%FFData,2), UBOUND(OutData%FFData,2)
              DO i1 = LBOUND(OutData%FFData,1), UBOUND(OutData%FFData,1)
                OutData%FFData(i1,i2,i3,i4,i5) = REAL(ReKiBuf(Re_Xferred), SiKi)
                Re_Xferred = Re_Xferred + 1
              END DO
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! X_unfrozen not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%X_unfrozen)) DEALLOCATE(OutData%X_unfrozen)
    ALLOCATE(OutData%X_unfrozen(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%X_unfrozen.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%X_unfrozen,1), UBOUND(OutData%X_unfrozen,1)
        OutData%X_unfrozen(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%Nlongi = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AvaiData not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AvaiData)) DEALLOCATE(OutData%AvaiData)
    ALLOCATE(OutData%AvaiData(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AvaiData.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%AvaiData,2), UBOUND(OutData%AvaiData,2)
        DO i1 = LBOUND(OutData%AvaiData,1), UBOUND(OutData%AvaiData,1)
          OutData%AvaiData(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    OutData%AvaiTimeEnd = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Periodic = TRANSFER(IntKiBuf(Int_Xferred), OutData%Periodic)
    Int_Xferred = Int_Xferred + 1
    OutData%TowerDataExist = TRANSFER(IntKiBuf(Int_Xferred), OutData%TowerDataExist)
    Int_Xferred = Int_Xferred + 1
    OutData%DT = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FFTower not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FFTower)) DEALLOCATE(OutData%FFTower)
    ALLOCATE(OutData%FFTower(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FFTower.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%FFTower,3), UBOUND(OutData%FFTower,3)
        DO i2 = LBOUND(OutData%FFTower,2), UBOUND(OutData%FFTower,2)
          DO i1 = LBOUND(OutData%FFTower,1), UBOUND(OutData%FFTower,1)
            OutData%FFTower(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), SiKi)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
    OutData%FFDTime = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%FFRate = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%FFYHWid = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%FFZHWid = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%RefHt = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%GridBase = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InitXPosition = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InvFFYD = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InvFFZD = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InvMFFWS = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MeanFFWS = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%TotalTime = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%NFFComp = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NFFSteps = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NYGrids = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NZGrids = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NTGrids = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WindFileFormat = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%EvolutionFlag = TRANSFER(IntKiBuf(Int_Xferred), OutData%EvolutionFlag)
    Int_Xferred = Int_Xferred + 1
    OutData%AvailabilityFlag = TRANSFER(IntKiBuf(Int_Xferred), OutData%AvailabilityFlag)
    Int_Xferred = Int_Xferred + 1
    OutData%BladeBlockageFlag = TRANSFER(IntKiBuf(Int_Xferred), OutData%BladeBlockageFlag)
    Int_Xferred = Int_Xferred + 1
    OutData%SpinnerMountedFlag = TRANSFER(IntKiBuf(Int_Xferred), OutData%SpinnerMountedFlag)
    Int_Xferred = Int_Xferred + 1
    OutData%NearestInterpFlag = TRANSFER(IntKiBuf(Int_Xferred), OutData%NearestInterpFlag)
    Int_Xferred = Int_Xferred + 1
    OutData%NBlade = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NELM = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BladeELMCL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BladeELMCL)) DEALLOCATE(OutData%BladeELMCL)
    ALLOCATE(OutData%BladeELMCL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeELMCL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BladeELMCL,1), UBOUND(OutData%BladeELMCL,1)
        OutData%BladeELMCL(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%AeroynMode = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE LidarSim_UnPackParam

 SUBROUTINE LidarSim_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(LidarSim_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(LidarSim_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcInputData%NacelleMotion, DstInputData%NacelleMotion, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcInputData%HubMotion, DstInputData%HubMotion, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInputData%BladeMotion)) THEN
  i1_l = LBOUND(SrcInputData%BladeMotion,1)
  i1_u = UBOUND(SrcInputData%BladeMotion,1)
  IF (.NOT. ALLOCATED(DstInputData%BladeMotion)) THEN 
    ALLOCATE(DstInputData%BladeMotion(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%BladeMotion.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%BladeMotion,1), UBOUND(SrcInputData%BladeMotion,1)
      CALL MeshCopy( SrcInputData%BladeMotion(i1), DstInputData%BladeMotion(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE LidarSim_CopyInput

 SUBROUTINE LidarSim_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(LidarSim_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'LidarSim_DestroyInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%NacelleMotion, ErrStat, ErrMsg )
  CALL MeshDestroy( InputData%HubMotion, ErrStat, ErrMsg )
IF (ALLOCATED(InputData%BladeMotion)) THEN
DO i1 = LBOUND(InputData%BladeMotion,1), UBOUND(InputData%BladeMotion,1)
  CALL MeshDestroy( InputData%BladeMotion(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InputData%BladeMotion)
ENDIF
 END SUBROUTINE LidarSim_DestroyInput

 SUBROUTINE LidarSim_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(LidarSim_InputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_PackInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! NacelleMotion: size of buffers for each call to pack subtype
      CALL MeshPack( InData%NacelleMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! NacelleMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! NacelleMotion
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! NacelleMotion
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! NacelleMotion
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! HubMotion: size of buffers for each call to pack subtype
      CALL MeshPack( InData%HubMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! HubMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! HubMotion
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! HubMotion
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! HubMotion
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  Int_BufSz   = Int_BufSz   + 1     ! BladeMotion allocated yes/no
  IF ( ALLOCATED(InData%BladeMotion) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BladeMotion upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%BladeMotion,1), UBOUND(InData%BladeMotion,1)
      Int_BufSz   = Int_BufSz + 3  ! BladeMotion: size of buffers for each call to pack subtype
      CALL MeshPack( InData%BladeMotion(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! BladeMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BladeMotion
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BladeMotion
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BladeMotion
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL MeshPack( InData%NacelleMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! NacelleMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL MeshPack( InData%HubMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! HubMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
  IF ( .NOT. ALLOCATED(InData%BladeMotion) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BladeMotion,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BladeMotion,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%BladeMotion,1), UBOUND(InData%BladeMotion,1)
      CALL MeshPack( InData%BladeMotion(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! BladeMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
 END SUBROUTINE LidarSim_PackInput

 SUBROUTINE LidarSim_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(LidarSim_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_UnPackInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%NacelleMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! NacelleMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%HubMotion, Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! HubMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BladeMotion not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BladeMotion)) DEALLOCATE(OutData%BladeMotion)
    ALLOCATE(OutData%BladeMotion(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeMotion.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%BladeMotion,1), UBOUND(OutData%BladeMotion,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%BladeMotion(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! BladeMotion 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
 END SUBROUTINE LidarSim_UnPackInput

 SUBROUTINE LidarSim_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(LidarSim_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(LidarSim_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_CopyInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileData%Echo = SrcInputFileData%Echo
    DstInputFileData%MAXDLLChainOutputs = SrcInputFileData%MAXDLLChainOutputs
    DstInputFileData%TrajectoryType = SrcInputFileData%TrajectoryType
    DstInputFileData%WeightingType = SrcInputFileData%WeightingType
    DstInputFileData%LidarPositionX_N = SrcInputFileData%LidarPositionX_N
    DstInputFileData%LidarPositionY_N = SrcInputFileData%LidarPositionY_N
    DstInputFileData%LidarPositionZ_N = SrcInputFileData%LidarPositionZ_N
    DstInputFileData%RollAngle_N = SrcInputFileData%RollAngle_N
    DstInputFileData%PitchAngle_N = SrcInputFileData%PitchAngle_N
    DstInputFileData%YawAngle_N = SrcInputFileData%YawAngle_N
    DstInputFileData%URef = SrcInputFileData%URef
    DstInputFileData%t_measurement_interval = SrcInputFileData%t_measurement_interval
    DstInputFileData%NumberOfPoints_Cartesian = SrcInputFileData%NumberOfPoints_Cartesian
IF (ALLOCATED(SrcInputFileData%X_Cartesian_L)) THEN
  i1_l = LBOUND(SrcInputFileData%X_Cartesian_L,1)
  i1_u = UBOUND(SrcInputFileData%X_Cartesian_L,1)
  IF (.NOT. ALLOCATED(DstInputFileData%X_Cartesian_L)) THEN 
    ALLOCATE(DstInputFileData%X_Cartesian_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%X_Cartesian_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%X_Cartesian_L = SrcInputFileData%X_Cartesian_L
ENDIF
IF (ALLOCATED(SrcInputFileData%Y_Cartesian_L)) THEN
  i1_l = LBOUND(SrcInputFileData%Y_Cartesian_L,1)
  i1_u = UBOUND(SrcInputFileData%Y_Cartesian_L,1)
  IF (.NOT. ALLOCATED(DstInputFileData%Y_Cartesian_L)) THEN 
    ALLOCATE(DstInputFileData%Y_Cartesian_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%Y_Cartesian_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%Y_Cartesian_L = SrcInputFileData%Y_Cartesian_L
ENDIF
IF (ALLOCATED(SrcInputFileData%Z_Cartesian_L)) THEN
  i1_l = LBOUND(SrcInputFileData%Z_Cartesian_L,1)
  i1_u = UBOUND(SrcInputFileData%Z_Cartesian_L,1)
  IF (.NOT. ALLOCATED(DstInputFileData%Z_Cartesian_L)) THEN 
    ALLOCATE(DstInputFileData%Z_Cartesian_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%Z_Cartesian_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%Z_Cartesian_L = SrcInputFileData%Z_Cartesian_L
ENDIF
    DstInputFileData%NumberOfPoints_Spherical = SrcInputFileData%NumberOfPoints_Spherical
    DstInputFileData%GatesPerBeam = SrcInputFileData%GatesPerBeam
IF (ALLOCATED(SrcInputFileData%Azimuth)) THEN
  i1_l = LBOUND(SrcInputFileData%Azimuth,1)
  i1_u = UBOUND(SrcInputFileData%Azimuth,1)
  IF (.NOT. ALLOCATED(DstInputFileData%Azimuth)) THEN 
    ALLOCATE(DstInputFileData%Azimuth(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%Azimuth.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%Azimuth = SrcInputFileData%Azimuth
ENDIF
IF (ALLOCATED(SrcInputFileData%Elevation)) THEN
  i1_l = LBOUND(SrcInputFileData%Elevation,1)
  i1_u = UBOUND(SrcInputFileData%Elevation,1)
  IF (.NOT. ALLOCATED(DstInputFileData%Elevation)) THEN 
    ALLOCATE(DstInputFileData%Elevation(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%Elevation.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%Elevation = SrcInputFileData%Elevation
ENDIF
IF (ALLOCATED(SrcInputFileData%Range)) THEN
  i1_l = LBOUND(SrcInputFileData%Range,1)
  i1_u = UBOUND(SrcInputFileData%Range,1)
  i2_l = LBOUND(SrcInputFileData%Range,2)
  i2_u = UBOUND(SrcInputFileData%Range,2)
  IF (.NOT. ALLOCATED(DstInputFileData%Range)) THEN 
    ALLOCATE(DstInputFileData%Range(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%Range.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%Range = SrcInputFileData%Range
ENDIF
    DstInputFileData%FWHM = SrcInputFileData%FWHM
    DstInputFileData%PointsToEvaluate = SrcInputFileData%PointsToEvaluate
    DstInputFileData%ManualWeightingPoints = SrcInputFileData%ManualWeightingPoints
IF (ALLOCATED(SrcInputFileData%ManualWeightingDistance)) THEN
  i1_l = LBOUND(SrcInputFileData%ManualWeightingDistance,1)
  i1_u = UBOUND(SrcInputFileData%ManualWeightingDistance,1)
  IF (.NOT. ALLOCATED(DstInputFileData%ManualWeightingDistance)) THEN 
    ALLOCATE(DstInputFileData%ManualWeightingDistance(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%ManualWeightingDistance.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%ManualWeightingDistance = SrcInputFileData%ManualWeightingDistance
ENDIF
IF (ALLOCATED(SrcInputFileData%ManualWeighting)) THEN
  i1_l = LBOUND(SrcInputFileData%ManualWeighting,1)
  i1_u = UBOUND(SrcInputFileData%ManualWeighting,1)
  IF (.NOT. ALLOCATED(DstInputFileData%ManualWeighting)) THEN 
    ALLOCATE(DstInputFileData%ManualWeighting(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%ManualWeighting.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%ManualWeighting = SrcInputFileData%ManualWeighting
ENDIF
    DstInputFileData%EvolutionFlag = SrcInputFileData%EvolutionFlag
    DstInputFileData%EvolutionFilenameRoot = SrcInputFileData%EvolutionFilenameRoot
    DstInputFileData%AvailabilityFlag = SrcInputFileData%AvailabilityFlag
    DstInputFileData%AvailabilityFilenameRoot = SrcInputFileData%AvailabilityFilenameRoot
    DstInputFileData%BladeBlockageFlag = SrcInputFileData%BladeBlockageFlag
    DstInputFileData%SpinnerMountedFlag = SrcInputFileData%SpinnerMountedFlag
    DstInputFileData%NearestInterpFlag = SrcInputFileData%NearestInterpFlag
IF (ALLOCATED(SrcInputFileData%OutList)) THEN
  i1_l = LBOUND(SrcInputFileData%OutList,1)
  i1_u = UBOUND(SrcInputFileData%OutList,1)
  IF (.NOT. ALLOCATED(DstInputFileData%OutList)) THEN 
    ALLOCATE(DstInputFileData%OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%OutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%OutList = SrcInputFileData%OutList
ENDIF
    DstInputFileData%NumOuts = SrcInputFileData%NumOuts
 END SUBROUTINE LidarSim_CopyInputFile

 SUBROUTINE LidarSim_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(LidarSim_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'LidarSim_DestroyInputFile'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputFileData%X_Cartesian_L)) THEN
  DEALLOCATE(InputFileData%X_Cartesian_L)
ENDIF
IF (ALLOCATED(InputFileData%Y_Cartesian_L)) THEN
  DEALLOCATE(InputFileData%Y_Cartesian_L)
ENDIF
IF (ALLOCATED(InputFileData%Z_Cartesian_L)) THEN
  DEALLOCATE(InputFileData%Z_Cartesian_L)
ENDIF
IF (ALLOCATED(InputFileData%Azimuth)) THEN
  DEALLOCATE(InputFileData%Azimuth)
ENDIF
IF (ALLOCATED(InputFileData%Elevation)) THEN
  DEALLOCATE(InputFileData%Elevation)
ENDIF
IF (ALLOCATED(InputFileData%Range)) THEN
  DEALLOCATE(InputFileData%Range)
ENDIF
IF (ALLOCATED(InputFileData%ManualWeightingDistance)) THEN
  DEALLOCATE(InputFileData%ManualWeightingDistance)
ENDIF
IF (ALLOCATED(InputFileData%ManualWeighting)) THEN
  DEALLOCATE(InputFileData%ManualWeighting)
ENDIF
IF (ALLOCATED(InputFileData%OutList)) THEN
  DEALLOCATE(InputFileData%OutList)
ENDIF
 END SUBROUTINE LidarSim_DestroyInputFile

 SUBROUTINE LidarSim_PackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(LidarSim_InputFile),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_PackInputFile'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! Echo
      Int_BufSz  = Int_BufSz  + 1  ! MAXDLLChainOutputs
      Int_BufSz  = Int_BufSz  + 1  ! TrajectoryType
      Int_BufSz  = Int_BufSz  + 1  ! WeightingType
      Re_BufSz   = Re_BufSz   + 1  ! LidarPositionX_N
      Re_BufSz   = Re_BufSz   + 1  ! LidarPositionY_N
      Re_BufSz   = Re_BufSz   + 1  ! LidarPositionZ_N
      Re_BufSz   = Re_BufSz   + 1  ! RollAngle_N
      Re_BufSz   = Re_BufSz   + 1  ! PitchAngle_N
      Re_BufSz   = Re_BufSz   + 1  ! YawAngle_N
      Re_BufSz   = Re_BufSz   + 1  ! URef
      Re_BufSz   = Re_BufSz   + 1  ! t_measurement_interval
      Int_BufSz  = Int_BufSz  + 1  ! NumberOfPoints_Cartesian
  Int_BufSz   = Int_BufSz   + 1     ! X_Cartesian_L allocated yes/no
  IF ( ALLOCATED(InData%X_Cartesian_L) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! X_Cartesian_L upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%X_Cartesian_L)  ! X_Cartesian_L
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Y_Cartesian_L allocated yes/no
  IF ( ALLOCATED(InData%Y_Cartesian_L) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Y_Cartesian_L upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Y_Cartesian_L)  ! Y_Cartesian_L
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Z_Cartesian_L allocated yes/no
  IF ( ALLOCATED(InData%Z_Cartesian_L) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Z_Cartesian_L upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Z_Cartesian_L)  ! Z_Cartesian_L
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NumberOfPoints_Spherical
      Int_BufSz  = Int_BufSz  + 1  ! GatesPerBeam
  Int_BufSz   = Int_BufSz   + 1     ! Azimuth allocated yes/no
  IF ( ALLOCATED(InData%Azimuth) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Azimuth upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Azimuth)  ! Azimuth
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Elevation allocated yes/no
  IF ( ALLOCATED(InData%Elevation) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Elevation upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Elevation)  ! Elevation
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Range allocated yes/no
  IF ( ALLOCATED(InData%Range) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Range upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Range)  ! Range
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! FWHM
      Int_BufSz  = Int_BufSz  + 1  ! PointsToEvaluate
      Int_BufSz  = Int_BufSz  + 1  ! ManualWeightingPoints
  Int_BufSz   = Int_BufSz   + 1     ! ManualWeightingDistance allocated yes/no
  IF ( ALLOCATED(InData%ManualWeightingDistance) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ManualWeightingDistance upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ManualWeightingDistance)  ! ManualWeightingDistance
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ManualWeighting allocated yes/no
  IF ( ALLOCATED(InData%ManualWeighting) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ManualWeighting upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ManualWeighting)  ! ManualWeighting
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! EvolutionFlag
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%EvolutionFilenameRoot)  ! EvolutionFilenameRoot
      Int_BufSz  = Int_BufSz  + 1  ! AvailabilityFlag
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%AvailabilityFilenameRoot)  ! AvailabilityFilenameRoot
      Int_BufSz  = Int_BufSz  + 1  ! BladeBlockageFlag
      Int_BufSz  = Int_BufSz  + 1  ! SpinnerMountedFlag
      Int_BufSz  = Int_BufSz  + 1  ! NearestInterpFlag
  Int_BufSz   = Int_BufSz   + 1     ! OutList allocated yes/no
  IF ( ALLOCATED(InData%OutList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! OutList upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%OutList)*LEN(InData%OutList)  ! OutList
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = TRANSFER(InData%Echo, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%MAXDLLChainOutputs
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%TrajectoryType
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WeightingType
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%LidarPositionX_N
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%LidarPositionY_N
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%LidarPositionZ_N
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%RollAngle_N
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%PitchAngle_N
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%YawAngle_N
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%URef
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%t_measurement_interval
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NumberOfPoints_Cartesian
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%X_Cartesian_L) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%X_Cartesian_L,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%X_Cartesian_L,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%X_Cartesian_L,1), UBOUND(InData%X_Cartesian_L,1)
        ReKiBuf(Re_Xferred) = InData%X_Cartesian_L(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Y_Cartesian_L) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Y_Cartesian_L,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Y_Cartesian_L,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Y_Cartesian_L,1), UBOUND(InData%Y_Cartesian_L,1)
        ReKiBuf(Re_Xferred) = InData%Y_Cartesian_L(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Z_Cartesian_L) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Z_Cartesian_L,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Z_Cartesian_L,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Z_Cartesian_L,1), UBOUND(InData%Z_Cartesian_L,1)
        ReKiBuf(Re_Xferred) = InData%Z_Cartesian_L(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NumberOfPoints_Spherical
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%GatesPerBeam
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%Azimuth) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Azimuth,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Azimuth,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Azimuth,1), UBOUND(InData%Azimuth,1)
        ReKiBuf(Re_Xferred) = InData%Azimuth(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Elevation) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Elevation,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Elevation,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Elevation,1), UBOUND(InData%Elevation,1)
        ReKiBuf(Re_Xferred) = InData%Elevation(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Range) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Range,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Range,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Range,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Range,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Range,2), UBOUND(InData%Range,2)
        DO i1 = LBOUND(InData%Range,1), UBOUND(InData%Range,1)
          ReKiBuf(Re_Xferred) = InData%Range(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%FWHM
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%PointsToEvaluate
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%ManualWeightingPoints
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%ManualWeightingDistance) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ManualWeightingDistance,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ManualWeightingDistance,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%ManualWeightingDistance,1), UBOUND(InData%ManualWeightingDistance,1)
        ReKiBuf(Re_Xferred) = InData%ManualWeightingDistance(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%ManualWeighting) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ManualWeighting,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ManualWeighting,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%ManualWeighting,1), UBOUND(InData%ManualWeighting,1)
        ReKiBuf(Re_Xferred) = InData%ManualWeighting(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = TRANSFER(InData%EvolutionFlag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%EvolutionFilenameRoot)
      IntKiBuf(Int_Xferred) = ICHAR(InData%EvolutionFilenameRoot(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    IntKiBuf(Int_Xferred) = TRANSFER(InData%AvailabilityFlag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%AvailabilityFilenameRoot)
      IntKiBuf(Int_Xferred) = ICHAR(InData%AvailabilityFilenameRoot(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    IntKiBuf(Int_Xferred) = TRANSFER(InData%BladeBlockageFlag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%SpinnerMountedFlag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%NearestInterpFlag, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%OutList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%OutList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%OutList,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%OutList,1), UBOUND(InData%OutList,1)
        DO I = 1, LEN(InData%OutList)
          IntKiBuf(Int_Xferred) = ICHAR(InData%OutList(i1)(I:I), IntKi)
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%NumOuts
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE LidarSim_PackInputFile

 SUBROUTINE LidarSim_UnPackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(LidarSim_InputFile), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'LidarSim_UnPackInputFile'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%Echo = TRANSFER(IntKiBuf(Int_Xferred), OutData%Echo)
    Int_Xferred = Int_Xferred + 1
    OutData%MAXDLLChainOutputs = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%TrajectoryType = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WeightingType = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%LidarPositionX_N = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%LidarPositionY_N = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%LidarPositionZ_N = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%RollAngle_N = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%PitchAngle_N = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%YawAngle_N = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%URef = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%t_measurement_interval = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%NumberOfPoints_Cartesian = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! X_Cartesian_L not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%X_Cartesian_L)) DEALLOCATE(OutData%X_Cartesian_L)
    ALLOCATE(OutData%X_Cartesian_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%X_Cartesian_L.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%X_Cartesian_L,1), UBOUND(OutData%X_Cartesian_L,1)
        OutData%X_Cartesian_L(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Y_Cartesian_L not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Y_Cartesian_L)) DEALLOCATE(OutData%Y_Cartesian_L)
    ALLOCATE(OutData%Y_Cartesian_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Y_Cartesian_L.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Y_Cartesian_L,1), UBOUND(OutData%Y_Cartesian_L,1)
        OutData%Y_Cartesian_L(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Z_Cartesian_L not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Z_Cartesian_L)) DEALLOCATE(OutData%Z_Cartesian_L)
    ALLOCATE(OutData%Z_Cartesian_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Z_Cartesian_L.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Z_Cartesian_L,1), UBOUND(OutData%Z_Cartesian_L,1)
        OutData%Z_Cartesian_L(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%NumberOfPoints_Spherical = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%GatesPerBeam = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Azimuth not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Azimuth)) DEALLOCATE(OutData%Azimuth)
    ALLOCATE(OutData%Azimuth(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Azimuth.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Azimuth,1), UBOUND(OutData%Azimuth,1)
        OutData%Azimuth(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Elevation not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Elevation)) DEALLOCATE(OutData%Elevation)
    ALLOCATE(OutData%Elevation(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Elevation.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Elevation,1), UBOUND(OutData%Elevation,1)
        OutData%Elevation(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Range not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Range)) DEALLOCATE(OutData%Range)
    ALLOCATE(OutData%Range(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Range.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Range,2), UBOUND(OutData%Range,2)
        DO i1 = LBOUND(OutData%Range,1), UBOUND(OutData%Range,1)
          OutData%Range(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    OutData%FWHM = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%PointsToEvaluate = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%ManualWeightingPoints = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ManualWeightingDistance not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ManualWeightingDistance)) DEALLOCATE(OutData%ManualWeightingDistance)
    ALLOCATE(OutData%ManualWeightingDistance(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ManualWeightingDistance.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%ManualWeightingDistance,1), UBOUND(OutData%ManualWeightingDistance,1)
        OutData%ManualWeightingDistance(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ManualWeighting not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ManualWeighting)) DEALLOCATE(OutData%ManualWeighting)
    ALLOCATE(OutData%ManualWeighting(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ManualWeighting.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%ManualWeighting,1), UBOUND(OutData%ManualWeighting,1)
        OutData%ManualWeighting(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%EvolutionFlag = TRANSFER(IntKiBuf(Int_Xferred), OutData%EvolutionFlag)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%EvolutionFilenameRoot)
      OutData%EvolutionFilenameRoot(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%AvailabilityFlag = TRANSFER(IntKiBuf(Int_Xferred), OutData%AvailabilityFlag)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%AvailabilityFilenameRoot)
      OutData%AvailabilityFilenameRoot(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%BladeBlockageFlag = TRANSFER(IntKiBuf(Int_Xferred), OutData%BladeBlockageFlag)
    Int_Xferred = Int_Xferred + 1
    OutData%SpinnerMountedFlag = TRANSFER(IntKiBuf(Int_Xferred), OutData%SpinnerMountedFlag)
    Int_Xferred = Int_Xferred + 1
    OutData%NearestInterpFlag = TRANSFER(IntKiBuf(Int_Xferred), OutData%NearestInterpFlag)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! OutList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%OutList)) DEALLOCATE(OutData%OutList)
    ALLOCATE(OutData%OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%OutList,1), UBOUND(OutData%OutList,1)
        DO I = 1, LEN(OutData%OutList)
          OutData%OutList(i1)(I:I) = CHAR(IntKiBuf(Int_Xferred))
          Int_Xferred = Int_Xferred + 1
        END DO ! I
      END DO
  END IF
    OutData%NumOuts = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE LidarSim_UnPackInputFile


 SUBROUTINE LidarSim_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(LidarSim_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(LidarSim_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'LidarSim_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL LidarSim_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL LidarSim_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL LidarSim_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE LidarSim_Input_ExtrapInterp


 SUBROUTINE LidarSim_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(LidarSim_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(LidarSim_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(LidarSim_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'LidarSim_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
      CALL MeshExtrapInterp1(u1%NacelleMotion, u2%NacelleMotion, tin, u_out%NacelleMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp1(u1%HubMotion, u2%HubMotion, tin, u_out%HubMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%BladeMotion) .AND. ALLOCATED(u1%BladeMotion)) THEN
  DO i1 = LBOUND(u_out%BladeMotion,1),UBOUND(u_out%BladeMotion,1)
      CALL MeshExtrapInterp1(u1%BladeMotion(i1), u2%BladeMotion(i1), tin, u_out%BladeMotion(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
 END SUBROUTINE LidarSim_Input_ExtrapInterp1


 SUBROUTINE LidarSim_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(LidarSim_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(LidarSim_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(LidarSim_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(LidarSim_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'LidarSim_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
      CALL MeshExtrapInterp2(u1%NacelleMotion, u2%NacelleMotion, u3%NacelleMotion, tin, u_out%NacelleMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp2(u1%HubMotion, u2%HubMotion, u3%HubMotion, tin, u_out%HubMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%BladeMotion) .AND. ALLOCATED(u1%BladeMotion)) THEN
  DO i1 = LBOUND(u_out%BladeMotion,1),UBOUND(u_out%BladeMotion,1)
      CALL MeshExtrapInterp2(u1%BladeMotion(i1), u2%BladeMotion(i1), u3%BladeMotion(i1), tin, u_out%BladeMotion(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
 END SUBROUTINE LidarSim_Input_ExtrapInterp2


 SUBROUTINE LidarSim_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(LidarSim_OutputType), INTENT(IN)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(LidarSim_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'LidarSim_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL LidarSim_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL LidarSim_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL LidarSim_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE LidarSim_Output_ExtrapInterp


 SUBROUTINE LidarSim_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(LidarSim_OutputType), INTENT(IN)  :: y1    ! Output at t1 > t2
 TYPE(LidarSim_OutputType), INTENT(IN)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(LidarSim_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'LidarSim_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = -(y1%WriteOutput(i1) - y2%WriteOutput(i1))
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%SwapOutputs) .AND. ALLOCATED(y1%SwapOutputs)) THEN
  DO i1 = LBOUND(y_out%SwapOutputs,1),UBOUND(y_out%SwapOutputs,1)
    b = -(y1%SwapOutputs(i1) - y2%SwapOutputs(i1))
    y_out%SwapOutputs(i1) = y1%SwapOutputs(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%AllOutputs) .AND. ALLOCATED(y1%AllOutputs)) THEN
  DO i1 = LBOUND(y_out%AllOutputs,1),UBOUND(y_out%AllOutputs,1)
    b = -(y1%AllOutputs(i1) - y2%AllOutputs(i1))
    y_out%AllOutputs(i1) = y1%AllOutputs(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%IMUOutputs) .AND. ALLOCATED(y1%IMUOutputs)) THEN
  DO i1 = LBOUND(y_out%IMUOutputs,1),UBOUND(y_out%IMUOutputs,1)
    b = -(y1%IMUOutputs(i1) - y2%IMUOutputs(i1))
    y_out%IMUOutputs(i1) = y1%IMUOutputs(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE LidarSim_Output_ExtrapInterp1


 SUBROUTINE LidarSim_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(LidarSim_OutputType), INTENT(IN)  :: y1      ! Output at t1 > t2 > t3
 TYPE(LidarSim_OutputType), INTENT(IN)  :: y2      ! Output at t2 > t3
 TYPE(LidarSim_OutputType), INTENT(IN)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(LidarSim_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'LidarSim_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = (t(3)**2*(y1%WriteOutput(i1) - y2%WriteOutput(i1)) + t(2)**2*(-y1%WriteOutput(i1) + y3%WriteOutput(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%WriteOutput(i1) + t(3)*y2%WriteOutput(i1) - t(2)*y3%WriteOutput(i1) ) * scaleFactor
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%SwapOutputs) .AND. ALLOCATED(y1%SwapOutputs)) THEN
  DO i1 = LBOUND(y_out%SwapOutputs,1),UBOUND(y_out%SwapOutputs,1)
    b = (t(3)**2*(y1%SwapOutputs(i1) - y2%SwapOutputs(i1)) + t(2)**2*(-y1%SwapOutputs(i1) + y3%SwapOutputs(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%SwapOutputs(i1) + t(3)*y2%SwapOutputs(i1) - t(2)*y3%SwapOutputs(i1) ) * scaleFactor
    y_out%SwapOutputs(i1) = y1%SwapOutputs(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%AllOutputs) .AND. ALLOCATED(y1%AllOutputs)) THEN
  DO i1 = LBOUND(y_out%AllOutputs,1),UBOUND(y_out%AllOutputs,1)
    b = (t(3)**2*(y1%AllOutputs(i1) - y2%AllOutputs(i1)) + t(2)**2*(-y1%AllOutputs(i1) + y3%AllOutputs(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%AllOutputs(i1) + t(3)*y2%AllOutputs(i1) - t(2)*y3%AllOutputs(i1) ) * scaleFactor
    y_out%AllOutputs(i1) = y1%AllOutputs(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%IMUOutputs) .AND. ALLOCATED(y1%IMUOutputs)) THEN
  DO i1 = LBOUND(y_out%IMUOutputs,1),UBOUND(y_out%IMUOutputs,1)
    b = (t(3)**2*(y1%IMUOutputs(i1) - y2%IMUOutputs(i1)) + t(2)**2*(-y1%IMUOutputs(i1) + y3%IMUOutputs(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%IMUOutputs(i1) + t(3)*y2%IMUOutputs(i1) - t(2)*y3%IMUOutputs(i1) ) * scaleFactor
    y_out%IMUOutputs(i1) = y1%IMUOutputs(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE LidarSim_Output_ExtrapInterp2

END MODULE LidarSim_Types
!ENDOFREGISTRYGENERATEDFILE
